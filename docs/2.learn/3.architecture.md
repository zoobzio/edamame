---
title: Architecture
description: How edamame works with soy for SQL generation
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - Architecture
  - Internals
  - Soy
---

# Architecture

Edamame is a semantic layer over soy. Understanding this relationship helps you use both effectively.

## Layer Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      Your Application                       │
│                                                             │
│   factory.ExecQuery(ctx, "by-status", params)               │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                         Edamame                             │
│                                                             │
│  ┌─────────────┐  Spec → Builder conversion                 │
│  │  Factory[T] │  Named capability lookup                   │
│  │             │  Thread-safe registries                    │
│  │  Queries    │  Introspection (Spec, SpecJSON)            │
│  │  Selects    │  Event emission (capitan)                  │
│  │  Updates    │                                            │
│  │  Deletes    │                                            │
│  │  Aggregates │                                            │
│  └──────┬──────┘                                            │
└─────────┼───────────────────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────────────────┐
│                          Soy                             │
│                                                             │
│  Query builder API                                          │
│  Field validation (via ASTQL)                               │
│  Parameterized SQL generation                               │
│  Render() → {SQL, Params}                                   │
└─────────┬───────────────────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────────────────┐
│                          sqlx                               │
│                                                             │
│  Connection pooling                                         │
│  Named parameter binding                                    │
│  Struct scanning                                            │
└─────────────────────────────────────────────────────────────┘
```

## Responsibilities

### Edamame

- **Capability management** - Register, lookup, list, remove capabilities
- **Spec-to-builder conversion** - Transform declarative specs into soy builders
- **Execution wrappers** - Convenient `Exec*` methods with params
- **Introspection** - Export capability metadata as specs or JSON
- **Events** - Emit capability lifecycle events via capitan

### Soy

- **Query building** - Fluent API for constructing SQL
- **Field validation** - Validate field names against model metadata
- **Operator validation** - Ensure operators are safe and valid
- **SQL generation** - Render builders to parameterized SQL
- **Execution** - Execute queries via sqlx

### When to Use Each

| Task                     | Use                           |
| ------------------------ | ----------------------------- |
| Define named operations  | Edamame capabilities          |
| Execute named operations | `factory.Exec*` methods       |
| Introspect capabilities  | `factory.Spec()`              |
| Ad-hoc queries           | `factory.Soy().Query()...` |
| Custom SQL construction  | Soy builder API            |

## Spec-to-Builder Flow

When you call `factory.ExecQuery(ctx, "by-status", params)`:

1. **Lookup** - Factory finds the capability by name in the registry
2. **Convert** - Spec is converted to a soy builder:
   ```go
   // QuerySpec → soy.Query[T]
   builder := factory.queryFromSpec(cap.Spec)
   ```
3. **Render** - Builder generates SQL:
   ```go
   result, err := builder.Render()
   // result.SQL = "SELECT ... FROM users WHERE status = $1"
   // result.Params = []any{"active"}
   ```
4. **Execute** - sqlx runs the parameterized query:
   ```go
   rows, err := db.QueryxContext(ctx, result.SQL, result.Params...)
   ```
5. **Scan** - Results are scanned into structs

## Thread Safety

Factory registries use `sync.RWMutex`:

- **Read operations** (Query, Select, Has*, Get*, List\*) acquire read lock
- **Write operations** (Add*, Remove*) acquire write lock

This allows concurrent query execution without blocking.

```go
// These can run concurrently
go factory.ExecQuery(ctx, "by-status", params1)
go factory.ExecQuery(ctx, "by-status", params2)

// This blocks reads while adding
factory.AddQuery(cap)
```

## Security Model

SQL injection protection flows through the entire stack:

1. **Edamame** - Specs are data, not SQL strings
2. **Soy** - Field names validated against model metadata
3. **Soy** - Operators validated against allowlist
4. **Soy** - All values become bound parameters
5. **sqlx** - Parameters passed separately from SQL

```go
// User input
params := map[string]any{"status": userInput}

// Never interpolated into SQL
factory.ExecQuery(ctx, "by-status", params)

// Becomes:
// SQL: "SELECT ... WHERE status = $1"
// Args: [userInput]  // Bound separately
```

## Event Integration

Edamame emits events via capitan for observability:

| Signal               | When                     | Fields                        |
| -------------------- | ------------------------ | ----------------------------- |
| `FactoryCreated`     | Factory initialized      | `table`                       |
| `CapabilityAdded`    | Capability registered    | `table`, `capability`, `type` |
| `CapabilityRemoved`  | Capability unregistered  | `table`, `capability`, `type` |
| `CapabilityNotFound` | Lookup failed            | `table`, `capability`, `type` |
| `PrimaryKeyNotFound` | No primarykey constraint | `table`                       |

Hook these for monitoring:

```go
capitan.Hook(edamame.CapabilityNotFound, func(ctx context.Context, e *capitan.Event) {
    table, _ := edamame.KeyTable.From(e)
    cap, _ := edamame.KeyCapability.From(e)
    log.Printf("Capability %s not found on %s", cap, table)
})
```

## Direct Soy Access

For operations not covered by capabilities, access soy directly:

```go
// Get the underlying soy instance
c := factory.Soy()

// Use soy's fluent API
users, err := c.Query().
    Where("age", ">=", "min_age").
    Where("status", "=", "status").
    OrderBy("name", "asc").
    Limit(10).
    Exec(ctx, params)
```

This bypasses capability management but still benefits from:

- Field validation
- Parameterized queries
- Type-safe results
