---
title: Architecture
description: How edamame works with cereal for SQL generation
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - Architecture
  - Internals
  - Cereal
---

# Architecture

Edamame is a semantic layer over cereal. Understanding this relationship helps you use both effectively.

## Layer Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      Your Application                        │
│                                                             │
│   factory.ExecQuery(ctx, "by-status", params)               │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                         Edamame                             │
│                                                             │
│  ┌─────────────┐  Spec → Builder conversion                 │
│  │  Factory[T] │  Named capability lookup                   │
│  │             │  Thread-safe registries                    │
│  │  Queries    │  Introspection (Spec, SpecJSON)            │
│  │  Selects    │  Event emission (capitan)                  │
│  │  Updates    │                                            │
│  │  Deletes    │                                            │
│  │  Aggregates │                                            │
│  └──────┬──────┘                                            │
└─────────┼───────────────────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────────────────┐
│                          Cereal                             │
│                                                             │
│  Query builder API                                          │
│  Field validation (via ASTQL)                               │
│  Parameterized SQL generation                               │
│  Render() → {SQL, Params}                                   │
└─────────┬───────────────────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────────────────┐
│                          sqlx                               │
│                                                             │
│  Connection pooling                                         │
│  Named parameter binding                                    │
│  Struct scanning                                            │
└─────────────────────────────────────────────────────────────┘
```

## Responsibilities

### Edamame

- **Capability management** - Register, lookup, list, remove capabilities
- **Spec-to-builder conversion** - Transform declarative specs into cereal builders
- **Execution wrappers** - Convenient `Exec*` methods with params
- **Introspection** - Export capability metadata as specs or JSON
- **Events** - Emit capability lifecycle events via capitan

### Cereal

- **Query building** - Fluent API for constructing SQL
- **Field validation** - Validate field names against model metadata
- **Operator validation** - Ensure operators are safe and valid
- **SQL generation** - Render builders to parameterized SQL
- **Execution** - Execute queries via sqlx

### When to Use Each

| Task | Use |
|------|-----|
| Define named operations | Edamame capabilities |
| Execute named operations | `factory.Exec*` methods |
| Introspect capabilities | `factory.Spec()` |
| Ad-hoc queries | `factory.Cereal().Query()...` |
| Custom SQL construction | Cereal builder API |

## Spec-to-Builder Flow

When you call `factory.ExecQuery(ctx, "by-status", params)`:

1. **Lookup** - Factory finds the capability by name in the registry
2. **Convert** - Spec is converted to a cereal builder:
   ```go
   // QuerySpec → cereal.Query[T]
   builder := factory.queryFromSpec(cap.Spec)
   ```
3. **Render** - Builder generates SQL:
   ```go
   result, err := builder.Render()
   // result.SQL = "SELECT ... FROM users WHERE status = $1"
   // result.Params = []any{"active"}
   ```
4. **Execute** - sqlx runs the parameterized query:
   ```go
   rows, err := db.QueryxContext(ctx, result.SQL, result.Params...)
   ```
5. **Scan** - Results are scanned into structs

## Thread Safety

Factory registries use `sync.RWMutex`:

- **Read operations** (Query, Select, Has*, Get*, List*) acquire read lock
- **Write operations** (Add*, Remove*) acquire write lock

This allows concurrent query execution without blocking.

```go
// These can run concurrently
go factory.ExecQuery(ctx, "by-status", params1)
go factory.ExecQuery(ctx, "by-status", params2)

// This blocks reads while adding
factory.AddQuery(cap)
```

## Security Model

SQL injection protection flows through the entire stack:

1. **Edamame** - Specs are data, not SQL strings
2. **Cereal** - Field names validated against model metadata
3. **Cereal** - Operators validated against allowlist
4. **Cereal** - All values become bound parameters
5. **sqlx** - Parameters passed separately from SQL

```go
// User input
params := map[string]any{"status": userInput}

// Never interpolated into SQL
factory.ExecQuery(ctx, "by-status", params)

// Becomes:
// SQL: "SELECT ... WHERE status = $1"
// Args: [userInput]  // Bound separately
```

## Event Integration

Edamame emits events via capitan for observability:

| Signal | When | Fields |
|--------|------|--------|
| `FactoryCreated` | Factory initialized | `table` |
| `CapabilityAdded` | Capability registered | `table`, `capability`, `type` |
| `CapabilityRemoved` | Capability unregistered | `table`, `capability`, `type` |
| `CapabilityNotFound` | Lookup failed | `table`, `capability`, `type` |
| `PrimaryKeyNotFound` | No primarykey constraint | `table` |

Hook these for monitoring:

```go
capitan.Hook(edamame.CapabilityNotFound, func(ctx context.Context, e *capitan.Event) {
    table, _ := edamame.KeyTable.From(e)
    cap, _ := edamame.KeyCapability.From(e)
    log.Printf("Capability %s not found on %s", cap, table)
})
```

## Direct Cereal Access

For operations not covered by capabilities, access cereal directly:

```go
// Get the underlying cereal instance
c := factory.Cereal()

// Use cereal's fluent API
users, err := c.Query().
    Where("age", ">=", "min_age").
    Where("status", "=", "status").
    OrderBy("name", "asc").
    Limit(10).
    Exec(ctx, params)
```

This bypasses capability management but still benefits from:
- Field validation
- Parameterized queries
- Type-safe results
