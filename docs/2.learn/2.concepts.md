---
title: Core Concepts
description: Factories, capabilities, and specs - the building blocks of edamame
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - Concepts
  - Factory
  - Capabilities
  - Specs
---

# Core Concepts

Edamame has three primitives: factories, capabilities, and specs. Understanding these unlocks the full API.

## Factory

A factory is the central coordinator for a single model type. It holds capability registries and provides execution methods.

```go
factory, err := edamame.New[User](db, "users", renderer)
```

The factory:
- Wraps a soy instance for SQL building
- Maintains thread-safe capability registries
- Provides execution methods for each capability type
- Supports introspection via `Spec()` and `SpecJSON()`

### Struct Tags

Edamame uses struct tags to understand your model:

```go
type User struct {
    ID    int    `db:"id" type:"integer" constraints:"primarykey"`
    Email string `db:"email" type:"text" constraints:"notnull,unique"`
    Name  string `db:"name" type:"text"`
    Age   *int   `db:"age" type:"integer"`
}
```

| Tag | Purpose | Example |
|-----|---------|---------|
| `db` | Column name | `db:"user_id"` |
| `type` | SQL type | `type:"text"`, `type:"integer"` |
| `constraints` | Column constraints | `constraints:"primarykey,notnull"` |

The `constraints:"primarykey"` tag is essential—it determines which field is used for default select/delete capabilities.

### Default Capabilities

When you create a factory, these capabilities are registered automatically:

| Name | Type | Description |
|------|------|-------------|
| `query` | Query | Select all records |
| `select` | Select | Select by primary key |
| `delete` | Delete | Delete by primary key |
| `count` | Aggregate | Count all records |

## Capabilities

A capability is a named, reusable database operation. Each capability has:
- **Name** - Unique identifier for lookup
- **Description** - Human-readable explanation
- **Spec** - Declarative definition of the operation
- **Params** - Required parameters (auto-derived from spec)
- **Tags** - Optional metadata for categorization

### Capability Types

| Type | Returns | Use Case |
|------|---------|----------|
| Query | `[]*T` | Multi-record retrieval |
| Select | `*T` | Single-record retrieval |
| Update | `*T` | Modify and return record |
| Delete | `int64` | Remove records, return count |
| Aggregate | `float64` | COUNT, SUM, AVG, MIN, MAX |

### Adding Capabilities

```go
// Query capability (Add* methods return error for validation failures)
if err := factory.AddQuery(edamame.QueryCapability{
    Name:        "by-status",
    Description: "Find users by status",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "status", Operator: "=", Param: "status"},
        },
    },
    Tags: []string{"user", "filter"},
}); err != nil {
    log.Fatal(err)
}

// Select capability
_ = factory.AddSelect(edamame.SelectCapability{
    Name:        "by-email",
    Description: "Find user by email address",
    Spec: edamame.SelectSpec{
        Where: []edamame.ConditionSpec{
            {Field: "email", Operator: "=", Param: "email"},
        },
    },
})

// Update capability
_ = factory.AddUpdate(edamame.UpdateCapability{
    Name:        "activate",
    Description: "Activate a user by ID",
    Spec: edamame.UpdateSpec{
        Set: map[string]string{"active": "active"},
        Where: []edamame.ConditionSpec{
            {Field: "id", Operator: "=", Param: "id"},
        },
    },
})

// Aggregate capability
_ = factory.AddAggregate(edamame.AggregateCapability{
    Name:        "avg-age",
    Description: "Average age of all users",
    Spec:        edamame.AggregateSpec{Field: "age"},
    Func:        edamame.AggAvg,
})
```

### Checking and Removing

```go
// Check existence
if factory.HasQuery("by-status") {
    // ...
}

// Get capability metadata
cap, ok := factory.GetQuery("by-status")

// Remove capability
removed := factory.RemoveQuery("by-status")

// List all capabilities
names := factory.ListQueries()
```

## Specs

A spec is a declarative definition of a database operation. Specs are pure data—no SQL strings, no builder calls.

### QuerySpec

For multi-record retrieval:

```go
spec := edamame.QuerySpec{
    Fields:     []string{"id", "name", "email"},  // SELECT columns (empty = all)
    Where:      []edamame.ConditionSpec{...},     // WHERE clauses
    OrderBy:    []edamame.OrderBySpec{...},       // ORDER BY clauses
    GroupBy:    []string{"status"},               // GROUP BY columns
    Having:     []edamame.ConditionSpec{...},     // HAVING clauses
    Limit:      &limit,                           // LIMIT
    Offset:     &offset,                          // OFFSET
    Distinct:   true,                             // SELECT DISTINCT
    ForLocking: "update",                         // FOR UPDATE/SHARE
}
```

### SelectSpec

For single-record retrieval (same structure as QuerySpec):

```go
spec := edamame.SelectSpec{
    Fields:     []string{"id", "name"},
    Where:      []edamame.ConditionSpec{...},
    ForLocking: "share",
}
```

### UpdateSpec

For modifications:

```go
spec := edamame.UpdateSpec{
    Set: map[string]string{
        "name":   "new_name",    // field -> param mapping
        "status": "new_status",
    },
    Where: []edamame.ConditionSpec{...},
}
```

### DeleteSpec

For deletions:

```go
spec := edamame.DeleteSpec{
    Where: []edamame.ConditionSpec{...},
}
```

### AggregateSpec

For aggregate functions:

```go
spec := edamame.AggregateSpec{
    Field: "age",                           // Field to aggregate
    Where: []edamame.ConditionSpec{...},    // Optional filter
}
```

Use with `AggCount`, `AggSum`, `AggAvg`, `AggMin`, or `AggMax`.

## Conditions

Conditions define WHERE clauses. They can be simple or grouped.

### Simple Conditions

```go
cond := edamame.ConditionSpec{
    Field:    "age",
    Operator: ">=",
    Param:    "min_age",
}
```

### NULL Conditions

```go
// IS NULL
cond := edamame.ConditionSpec{
    Field:    "deleted_at",
    IsNull:   true,
    Operator: "IS NULL",
}

// IS NOT NULL
cond := edamame.ConditionSpec{
    Field:    "email",
    IsNull:   true,
    Operator: "IS NOT NULL",
}
```

### Grouped Conditions (OR)

```go
cond := edamame.ConditionSpec{
    Logic: "OR",
    Group: []edamame.ConditionSpec{
        {Field: "status", Operator: "=", Param: "status1"},
        {Field: "status", Operator: "=", Param: "status2"},
    },
}
```

### Supported Operators

| Operator | Description |
|----------|-------------|
| `=` | Equal |
| `!=`, `<>` | Not equal |
| `<`, `<=` | Less than |
| `>`, `>=` | Greater than |
| `LIKE`, `ILIKE` | Pattern matching |
| `IN` | Value in list |
| `IS NULL` | NULL check |
| `IS NOT NULL` | NOT NULL check |

## Ordering

```go
order := edamame.OrderBySpec{
    Field:     "created_at",
    Direction: "desc",      // "asc" or "desc"
    Nulls:     "last",      // "first" or "last" (optional)
}
```

### Expression-Based Ordering

For vector similarity or computed distances:

```go
order := edamame.OrderBySpec{
    Field:     "embedding",
    Operator:  "<->",           // pgvector distance operator
    Param:     "query_vector",
    Direction: "asc",
}
```

## Execution

Execute capabilities with params:

```go
// Query (multiple records)
users, err := factory.ExecQuery(ctx, "by-status", map[string]any{
    "status": "active",
})

// Select (single record)
user, err := factory.ExecSelect(ctx, "by-email", map[string]any{
    "email": "alice@example.com",
})

// Update
updated, err := factory.ExecUpdate(ctx, "activate", map[string]any{
    "id":     123,
    "active": true,
})

// Delete
count, err := factory.ExecDelete(ctx, "delete", map[string]any{
    "id": 123,
})

// Aggregate
avg, err := factory.ExecAggregate(ctx, "avg-age", nil)

// Insert (no capability needed)
inserted, err := factory.ExecInsert(ctx, &user)
```

### Transaction Support

All execution methods have `*Tx` variants:

```go
tx, err := db.BeginTxx(ctx, nil)

user, err := factory.ExecSelectTx(ctx, tx, "select", params)
_, err = factory.ExecUpdateTx(ctx, tx, "activate", params)

tx.Commit()
```

### Batch Operations

```go
// Batch insert
count, err := factory.ExecInsertBatch(ctx, users)

// Batch update
count, err := factory.ExecUpdateBatch(ctx, "activate", []map[string]any{
    {"id": 1, "active": true},
    {"id": 2, "active": true},
})
```

## Introspection

Get the full factory spec for documentation or LLM integration:

```go
// As Go structs
spec := factory.Spec()
fmt.Printf("Table: %s\n", spec.Table)
for _, q := range spec.Queries {
    fmt.Printf("Query: %s - %s\n", q.Name, q.Description)
    for _, p := range q.Params {
        fmt.Printf("  Param: %s (%s)\n", p.Name, p.Type)
    }
}

// As JSON
json, err := factory.SpecJSON()
```

The spec includes all registered capabilities with their names, descriptions, and derived parameter metadata.
