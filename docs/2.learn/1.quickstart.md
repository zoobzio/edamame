---
title: Quickstart
description: Get started with edamame in minutes
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - Quickstart
  - Getting Started
---

# Quickstart

## Requirements

Go 1.24 or later.

## Installation

```bash
go get github.com/zoobzio/edamame
```

## Basic Usage

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/jmoiron/sqlx"
    _ "github.com/lib/pq" // or mysql, sqlite3, mssql driver
    "github.com/zoobzio/astql/pkg/postgres" // or mysql, sqlite, mssql
    "github.com/zoobzio/edamame"
)

// Define your model with struct tags
type User struct {
    ID    int    `db:"id" type:"integer" constraints:"primarykey"`
    Email string `db:"email" type:"text" constraints:"notnull,unique"`
    Name  string `db:"name" type:"text"`
    Age   *int   `db:"age" type:"integer"`
}

func main() {
    // Connect to database (PostgreSQL shown; MySQL, SQLite, SQL Server also supported)
    db, err := sqlx.Connect("postgres", "postgres://user:pass@localhost/mydb?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }

    // Create factory (CRUD capabilities auto-registered)
    factory, err := edamame.New[User](db, "users", postgres.New())
    if err != nil {
        log.Fatal(err)
    }

    ctx := context.Background()

    // Query all users
    users, err := factory.ExecQuery(ctx, "query", nil)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Found %d users\n", len(users))

    // Select user by ID
    user, err := factory.ExecSelect(ctx, "select", map[string]any{"id": 1})
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("User: %s\n", user.Name)

    // Insert a new user
    age := 25
    newUser := &User{
        Email: "alice@example.com",
        Name:  "Alice",
        Age:   &age,
    }
    inserted, err := factory.ExecInsert(ctx, newUser)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Inserted user ID: %d\n", inserted.ID)

    // Count users
    count, err := factory.ExecAggregate(ctx, "count", nil)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Total users: %.0f\n", count)
}
```

## What's Happening

1. `New[User](db, "users", postgres.New())` creates a factory for the User type bound to the "users" table with the PostgreSQL renderer
2. Default CRUD capabilities are registered automatically based on struct tags
3. `ExecQuery` returns all records matching the capability's spec
4. `ExecSelect` returns a single record (or error if not found)
5. `ExecInsert` inserts a record and returns it with generated fields (like ID)
6. `ExecAggregate` runs an aggregate function and returns the result

## Adding Custom Capabilities

```go
// Add a query for active adult users
factory.AddQuery(edamame.QueryCapability{
    Name:        "active-adults",
    Description: "Find active users above minimum age",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "active", Operator: "=", Param: "active"},
            {Field: "age", Operator: ">=", Param: "min_age"},
        },
        OrderBy: []edamame.OrderBySpec{
            {Field: "name", Direction: "asc"},
        },
    },
})

// Use the custom capability
users, err := factory.ExecQuery(ctx, "active-adults", map[string]any{
    "active":  true,
    "min_age": 18,
})
```

## Introspecting Capabilities

```go
// Get all capability specs as Go structs
spec := factory.Spec()
fmt.Printf("Table: %s\n", spec.Table)
fmt.Printf("Queries: %d\n", len(spec.Queries))

// Get as JSON (useful for LLM integration)
json, err := factory.SpecJSON()
if err != nil {
    log.Fatal(err)
}
fmt.Println(string(json))
```

## Next Steps

- [Core Concepts](2.concepts.md) - Understand factories, capabilities, and specs
- [Adding Capabilities](../3.guides/2.capabilities.md) - Define custom queries, updates, and more
- [LLM Integration](../4.cookbook/1.llm-integration.md) - Use specs with AI assistants
