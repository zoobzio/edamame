---
title: Capabilities
description: Adding and managing custom capabilities
author: zoobzio
published: 2025-12-17
updated: 2025-12-22
tags:
  - Capabilities
  - Queries
  - Updates
  - Deletes
---

# Capabilities

This guide covers adding custom capabilities beyond the defaults.

## Queries

Queries return multiple records. Use for lists, search results, and filtered collections.

### Basic Query

```go
factory.AddQuery(edamame.QueryCapability{
    Name:        "active-users",
    Description: "Find all active users",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "active", Operator: "=", Param: "active"},
        },
    },
})

// Usage
users, err := factory.ExecQuery(ctx, "active-users", map[string]any{
    "active": true,
})
```

### With Ordering and Pagination

```go
limit := 20
offset := 0

factory.AddQuery(edamame.QueryCapability{
    Name:        "recent-users",
    Description: "Get users ordered by creation date",
    Spec: edamame.QuerySpec{
        OrderBy: []edamame.OrderBySpec{
            {Field: "created_at", Direction: "desc"},
        },
        Limit:  &limit,
        Offset: &offset,
    },
})
```

### With Field Selection

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "user-names",
    Spec: edamame.QuerySpec{
        Fields: []string{"id", "name"},  // Only select these columns
    },
})
```

### With Grouping

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "users-by-role",
    Spec: edamame.QuerySpec{
        Fields:  []string{"role", "COUNT(*) as count"},
        GroupBy: []string{"role"},
    },
})
```

### HAVING with Aggregates

Use `HavingAgg` for aggregate conditions in HAVING clauses:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "popular-roles",
    Spec: edamame.QuerySpec{
        Fields:  []string{"role"},
        GroupBy: []string{"role"},
        HavingAgg: []edamame.HavingAggSpec{
            {Func: "count", Field: "*", Operator: ">=", Param: "min_count"},
        },
    },
})

// Generates: SELECT role FROM users GROUP BY role HAVING COUNT(*) >= $1
```

Multiple aggregate conditions:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "high-value-roles",
    Spec: edamame.QuerySpec{
        Fields:  []string{"role"},
        GroupBy: []string{"role"},
        HavingAgg: []edamame.HavingAggSpec{
            {Func: "count", Field: "*", Operator: ">=", Param: "min_count"},
            {Func: "sum", Field: "balance", Operator: ">=", Param: "min_total"},
        },
    },
})
```

### DISTINCT ON (PostgreSQL)

Use `DistinctOn` for PostgreSQL's DISTINCT ON clause:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "latest-per-user",
    Spec: edamame.QuerySpec{
        DistinctOn: []string{"user_id"},
        OrderBy: []edamame.OrderBySpec{
            {Field: "user_id", Direction: "asc"},
            {Field: "created_at", Direction: "desc"},
        },
    },
})

// Generates: SELECT DISTINCT ON (user_id) * FROM ... ORDER BY user_id ASC, created_at DESC
```

### Complex Conditions

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "filtered-users",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "age", Operator: ">=", Param: "min_age"},
            {Field: "age", Operator: "<=", Param: "max_age"},
            {
                Logic: "OR",
                Group: []edamame.ConditionSpec{
                    {Field: "role", Operator: "=", Param: "role1"},
                    {Field: "role", Operator: "=", Param: "role2"},
                },
            },
        },
    },
})

// Generates: WHERE age >= $1 AND age <= $2 AND (role = $3 OR role = $4)
```

### BETWEEN Conditions

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "users-in-age-range",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "age", Between: true, LowParam: "min_age", HighParam: "max_age"},
        },
    },
})

// Generates: WHERE age BETWEEN $1 AND $2

// NOT BETWEEN
factory.AddQuery(edamame.QueryCapability{
    Name: "users-outside-range",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "age", NotBetween: true, LowParam: "min_age", HighParam: "max_age"},
        },
    },
})

// Generates: WHERE age NOT BETWEEN $1 AND $2
```

### Field-to-Field Comparisons

Compare two columns directly without parameters:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "modified-after-created",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "updated_at", Operator: ">", RightField: "created_at"},
        },
    },
})

// Generates: WHERE updated_at > created_at
```

### Parameterized Pagination

Use parameter-driven limits and offsets for flexible pagination:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "paginated-users",
    Spec: edamame.QuerySpec{
        LimitParam:  "page_size",
        OffsetParam: "offset",
        OrderBy: []edamame.OrderBySpec{
            {Field: "created_at", Direction: "desc"},
        },
    },
})

// Usage
users, err := factory.ExecQuery(ctx, "paginated-users", map[string]any{
    "page_size": 20,
    "offset":    40,  // Page 3
})
```

### Select Expressions

Add computed columns using SQL functions:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "users-with-computed",
    Spec: edamame.QuerySpec{
        Fields: []string{"id", "name"},
        SelectExprs: []edamame.SelectExprSpec{
            {Func: "upper", Field: "name", Alias: "upper_name"},
            {Func: "length", Field: "email", Alias: "email_length"},
            {Func: "count_star", Alias: "total"},
            {Func: "now", Alias: "query_time"},
        },
        GroupBy: []string{"id", "name"},
    },
})
```

Available functions include: `upper`, `lower`, `length`, `trim`, `concat`, `abs`, `ceil`, `floor`, `round`, `now`, `current_date`, `cast`, `count`, `sum`, `avg`, `min`, `max`, `coalesce`, `nullif`.

### With Row Locking

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "for-update",
    Spec: edamame.QuerySpec{
        Where:      []edamame.ConditionSpec{{Field: "status", Operator: "=", Param: "status"}},
        ForLocking: "update",  // FOR UPDATE
    },
})
```

Locking options: `"update"`, `"no_key_update"`, `"share"`, `"key_share"`

## Selects

Selects return a single record. Use for lookups by unique identifier.

### By Unique Field

```go
factory.AddSelect(edamame.SelectCapability{
    Name:        "by-email",
    Description: "Find user by email address",
    Spec: edamame.SelectSpec{
        Where: []edamame.ConditionSpec{
            {Field: "email", Operator: "=", Param: "email"},
        },
    },
})

// Usage - returns error if not found
user, err := factory.ExecSelect(ctx, "by-email", map[string]any{
    "email": "alice@example.com",
})
```

### With Locking

```go
factory.AddSelect(edamame.SelectCapability{
    Name: "for-share",
    Spec: edamame.SelectSpec{
        Where:      []edamame.ConditionSpec{{Field: "id", Operator: "=", Param: "id"}},
        ForLocking: "share",  // FOR SHARE
    },
})
```

## Updates

Updates modify records and return the updated row.

### Single Field Update

```go
factory.AddUpdate(edamame.UpdateCapability{
    Name:        "activate",
    Description: "Activate a user by ID",
    Spec: edamame.UpdateSpec{
        Set: map[string]string{
            "active": "active",  // field -> param
        },
        Where: []edamame.ConditionSpec{
            {Field: "id", Operator: "=", Param: "id"},
        },
    },
})

// Usage
updated, err := factory.ExecUpdate(ctx, "activate", map[string]any{
    "id":     123,
    "active": true,
})
```

### Multi-Field Update

```go
factory.AddUpdate(edamame.UpdateCapability{
    Name: "update-profile",
    Spec: edamame.UpdateSpec{
        Set: map[string]string{
            "name":  "new_name",
            "email": "new_email",
            "bio":   "new_bio",
        },
        Where: []edamame.ConditionSpec{
            {Field: "id", Operator: "=", Param: "id"},
        },
    },
})
```

### Batch Updates

```go
// Execute same update with different params
count, err := factory.ExecUpdateBatch(ctx, "activate", []map[string]any{
    {"id": 1, "active": true},
    {"id": 2, "active": true},
    {"id": 3, "active": false},
})
```

## Deletes

Deletes remove records and return the count of deleted rows.

### By Single Field

```go
factory.AddDelete(edamame.DeleteCapability{
    Name:        "by-status",
    Description: "Delete all users with given status",
    Spec: edamame.DeleteSpec{
        Where: []edamame.ConditionSpec{
            {Field: "status", Operator: "=", Param: "status"},
        },
    },
})

// Usage
count, err := factory.ExecDelete(ctx, "by-status", map[string]any{
    "status": "inactive",
})
```

### With Multiple Conditions

```go
factory.AddDelete(edamame.DeleteCapability{
    Name: "expired-sessions",
    Spec: edamame.DeleteSpec{
        Where: []edamame.ConditionSpec{
            {Field: "expires_at", Operator: "<", Param: "now"},
            {Field: "active", Operator: "=", Param: "active"},
        },
    },
})
```

## Aggregates

Aggregates compute values across records.

### Count

```go
factory.AddAggregate(edamame.AggregateCapability{
    Name:        "count-active",
    Description: "Count active users",
    Spec: edamame.AggregateSpec{
        Where: []edamame.ConditionSpec{
            {Field: "active", Operator: "=", Param: "active"},
        },
    },
    Func: edamame.AggCount,
})

count, err := factory.ExecAggregate(ctx, "count-active", map[string]any{
    "active": true,
})
```

### Sum, Avg, Min, Max

```go
// Sum
factory.AddAggregate(edamame.AggregateCapability{
    Name: "total-balance",
    Spec: edamame.AggregateSpec{Field: "balance"},
    Func: edamame.AggSum,
})

// Average
factory.AddAggregate(edamame.AggregateCapability{
    Name: "avg-age",
    Spec: edamame.AggregateSpec{Field: "age"},
    Func: edamame.AggAvg,
})

// Min/Max
factory.AddAggregate(edamame.AggregateCapability{
    Name: "youngest",
    Spec: edamame.AggregateSpec{Field: "age"},
    Func: edamame.AggMin,
})
```

## Inserts

Inserts don't use capabilitiesâ€”they're driven by struct fields:

```go
// Single insert
inserted, err := factory.ExecInsert(ctx, &user)

// Batch insert
count, err := factory.ExecInsertBatch(ctx, users)
```

### With Conflict Handling

For upsert patterns, use the underlying soy API:

```go
c := factory.Soy()

// ON CONFLICT DO NOTHING
result, err := c.Insert().
    OnConflictDoNothing("email").
    Exec(ctx, &user)

// ON CONFLICT DO UPDATE
result, err := c.Insert().
    OnConflict("email").
    DoUpdate(map[string]string{"name": "name"}).
    Exec(ctx, &user)
```

## Compound Queries

Compound queries combine multiple SELECT statements using set operations.

### UNION

```go
spec := edamame.CompoundQuerySpec{
    Base: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "role", Operator: "=", Param: "role1"},
        },
    },
    Operands: []edamame.CompoundOperand{
        {
            Operation: "union",
            Query: edamame.QuerySpec{
                Where: []edamame.ConditionSpec{
                    {Field: "role", Operator: "=", Param: "role2"},
                },
            },
        },
    },
    OrderBy: []edamame.OrderBySpec{
        {Field: "name", Direction: "asc"},
    },
}

users, err := factory.ExecCompound(ctx, spec, map[string]any{
    "role1": "admin",
    "role2": "moderator",
})
```

### Available Operations

| Operation | Description |
|-----------|-------------|
| `union` | Combine results, remove duplicates |
| `union_all` | Combine results, keep duplicates |
| `intersect` | Only rows in both queries |
| `intersect_all` | Intersection with duplicates |
| `except` | Rows in first but not second |
| `except_all` | Except with duplicates |

### Rendering for Inspection

```go
sql, err := factory.RenderCompound(spec)
// SELECT ... WHERE role = $1 UNION SELECT ... WHERE role = $2 ORDER BY name ASC
```

## Managing Capabilities

### Listing

```go
queries := factory.ListQueries()
selects := factory.ListSelects()
updates := factory.ListUpdates()
deletes := factory.ListDeletes()
aggregates := factory.ListAggregates()
```

### Checking Existence

```go
if factory.HasQuery("by-status") {
    // ...
}
```

### Getting Metadata

```go
cap, ok := factory.GetQuery("by-status")
if ok {
    fmt.Println(cap.Description)
    for _, p := range cap.Params {
        fmt.Printf("  %s: %s\n", p.Name, p.Type)
    }
}
```

### Removing

```go
removed := factory.RemoveQuery("old-query")
```

## Parameter Derivation

Params are automatically derived from specs:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "example",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "age", Operator: ">=", Param: "min_age"},
            {Field: "status", Operator: "=", Param: "status"},
        },
    },
    // Params auto-derived:
    // - min_age (type from age field)
    // - status (type from status field)
})
```

Override with explicit params if needed:

```go
factory.AddQuery(edamame.QueryCapability{
    Name: "example",
    Spec: edamame.QuerySpec{...},
    Params: []edamame.ParamSpec{
        {Name: "min_age", Type: "integer", Required: true, Description: "Minimum age"},
        {Name: "status", Type: "text", Required: false, Default: "active"},
    },
})
```
