---
title: Testing
description: Testing strategies for edamame-based applications
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - Testing
  - Helpers
  - Integration
---

# Testing

Edamame provides testing utilities in the `github.com/zoobzio/edamame/testing` package.

## Test Helpers

### QueryCapture

Capture rendered SQL for verification:

```go
import edamametesting "github.com/zoobzio/edamame/testing"

func TestQueryRendering(t *testing.T) {
    capture := edamametesting.NewQueryCapture()

    factory, _ := edamame.New[User](nil, "users")

    // Capture a rendered query
    sql, _ := factory.RenderQuery("query")
    capture.CaptureQuery("query", "query", sql, nil)

    // Verify
    if capture.Count() != 1 {
        t.Errorf("expected 1 query, got %d", capture.Count())
    }

    last := capture.Last()
    if last.Type != "query" {
        t.Errorf("expected type 'query', got %q", last.Type)
    }
}
```

### CapabilityCapture

Capture capability events via capitan:

```go
func TestCapabilityEvents(t *testing.T) {
    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    capture := edamametesting.NewCapabilityCapture()
    c.Hook(edamame.CapabilityAdded, capture.Handler())

    factory, _ := edamame.New[User](nil, "users")

    factory.AddQuery(edamame.QueryCapability{
        Name: "custom",
    })

    // Verify event captured
    caps := capture.ByAction("added")
    if len(caps) == 0 {
        t.Error("expected capability added event")
    }
}
```

### SpecValidator

Validate factory specs:

```go
func TestFactorySpec(t *testing.T) {
    factory, _ := edamame.New[User](nil, "users")
    factory.AddQuery(edamame.QueryCapability{Name: "custom"})

    spec := factory.Spec()
    validator := edamametesting.NewSpecValidator()

    if !validator.HasQuery(spec, "query") {
        t.Error("missing default query capability")
    }

    if !validator.HasQuery(spec, "custom") {
        t.Error("missing custom query capability")
    }

    total := validator.CountCapabilities(spec)
    if total < 5 {
        t.Errorf("expected at least 5 capabilities, got %d", total)
    }
}
```

### ParamBuilder

Build test parameters fluently:

```go
func TestWithParams(t *testing.T) {
    params := edamametesting.NewParamBuilder().
        Set("id", 123).
        Set("status", "active").
        Set("limit", 10).
        Build()

    // Use in tests
    users, err := factory.ExecQuery(ctx, "filtered", params)
}
```

## Unit Testing Without Database

Test capability registration and spec generation without a database:

```go
func TestCapabilities(t *testing.T) {
    // nil db is valid for testing capabilities
    factory, err := edamame.New[User](nil, "users")
    if err != nil {
        t.Fatal(err)
    }

    // Test default capabilities exist
    if !factory.HasQuery("query") {
        t.Error("missing default query")
    }
    if !factory.HasSelect("select") {
        t.Error("missing default select")
    }

    // Test adding custom capability
    factory.AddQuery(edamame.QueryCapability{
        Name:        "by-status",
        Description: "Find by status",
        Spec: edamame.QuerySpec{
            Where: []edamame.ConditionSpec{
                {Field: "status", Operator: "=", Param: "status"},
            },
        },
    })

    if !factory.HasQuery("by-status") {
        t.Error("custom capability not registered")
    }

    // Test spec generation
    spec := factory.Spec()
    if spec.Table != "users" {
        t.Errorf("expected table 'users', got %q", spec.Table)
    }

    // Test JSON generation
    json, err := factory.SpecJSON()
    if err != nil {
        t.Fatal(err)
    }
    if len(json) == 0 {
        t.Error("empty JSON spec")
    }
}
```

## Testing SQL Rendering

Verify generated SQL without executing:

```go
func TestSQLRendering(t *testing.T) {
    factory, _ := edamame.New[User](nil, "users")

    factory.AddQuery(edamame.QueryCapability{
        Name: "adults",
        Spec: edamame.QuerySpec{
            Where: []edamame.ConditionSpec{
                {Field: "age", Operator: ">=", Param: "min_age"},
            },
            OrderBy: []edamame.OrderBySpec{
                {Field: "name", Direction: "asc"},
            },
        },
    })

    sql, err := factory.RenderQuery("adults")
    if err != nil {
        t.Fatal(err)
    }

    // Verify SQL structure
    if !strings.Contains(sql, "WHERE") {
        t.Error("SQL missing WHERE clause")
    }
    if !strings.Contains(sql, "ORDER BY") {
        t.Error("SQL missing ORDER BY clause")
    }
}
```

## Integration Testing with Testcontainers

For database integration tests, use testcontainers:

```go
//go:build integration

package integration

import (
    "context"
    "testing"

    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

func TestWithPostgres(t *testing.T) {
    ctx := context.Background()

    // Start PostgreSQL container
    req := testcontainers.ContainerRequest{
        Image:        "postgres:16-alpine",
        ExposedPorts: []string{"5432/tcp"},
        WaitingFor:   wait.ForLog("database system is ready to accept connections"),
        Env: map[string]string{
            "POSTGRES_USER":     "test",
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB":       "testdb",
        },
    }

    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })
    if err != nil {
        t.Fatal(err)
    }
    defer container.Terminate(ctx)

    // Get connection details
    host, _ := container.Host(ctx)
    port, _ := container.MappedPort(ctx, "5432")

    // Connect and test
    dsn := fmt.Sprintf("host=%s port=%s user=test password=test dbname=testdb sslmode=disable", host, port.Port())
    db, err := sqlx.Connect("postgres", dsn)
    if err != nil {
        t.Fatal(err)
    }

    // Create table
    db.ExecContext(ctx, `CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL UNIQUE,
        name TEXT,
        age INTEGER
    )`)

    // Test factory
    factory, _ := edamame.New[User](db, "users")

    age := 25
    user := &User{Email: "test@example.com", Name: "Test", Age: &age}
    inserted, err := factory.ExecInsert(ctx, user)
    if err != nil {
        t.Fatal(err)
    }

    if inserted.ID == 0 {
        t.Error("expected non-zero ID")
    }
}
```

Run integration tests:

```bash
go test -tags=integration ./testing/integration/...
```

## Benchmarking

The `testing/benchmarks` package provides performance benchmarks:

```go
func BenchmarkQueryBuilding(b *testing.B) {
    factory, _ := edamame.New[User](nil, "users")

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, _ = factory.Query("query")
    }
}
```

Run benchmarks:

```bash
go test ./testing/benchmarks/... -bench=. -benchmem
```

## Testing Events

Verify capitan events are emitted correctly:

```go
func TestFactoryEmitsCreatedEvent(t *testing.T) {
    c := capitan.New(capitan.WithSyncMode())
    defer c.Shutdown()

    capture := edamametesting.NewFactoryEventCapture()
    c.Hook(edamame.FactoryCreated, capture.Handler())

    _, _ = edamame.New[User](nil, "users")

    if capture.Count() != 1 {
        t.Errorf("expected 1 factory created event, got %d", capture.Count())
    }

    tables := capture.Tables()
    if tables[0].Table != "users" {
        t.Errorf("expected table 'users', got %q", tables[0].Table)
    }
}
```

## Testing Transaction Behavior

```go
func TestTransaction(t *testing.T) {
    // ... setup db and factory ...

    tx, _ := db.BeginTxx(ctx, nil)

    // Insert in transaction
    user := &User{Email: "tx@test.com", Name: "TxTest"}
    inserted, err := factory.ExecInsertTx(ctx, tx, user)
    if err != nil {
        tx.Rollback()
        t.Fatal(err)
    }

    // Verify visible in transaction
    users, _ := factory.ExecQueryTx(ctx, tx, "query", nil)
    if len(users) != 1 {
        t.Error("expected 1 user in transaction")
    }

    // Rollback
    tx.Rollback()

    // Verify not visible after rollback
    users, _ = factory.ExecQuery(ctx, "query", nil)
    if len(users) != 0 {
        t.Error("expected 0 users after rollback")
    }
}
```

## Async Event Testing

Use `WaitForCount` for async event verification:

```go
func TestAsyncEvents(t *testing.T) {
    c := capitan.New()  // async mode
    defer c.Shutdown()

    capture := edamametesting.NewCapabilityCapture()
    c.Hook(edamame.CapabilityAdded, capture.Handler())

    factory, _ := edamame.New[User](nil, "users")
    factory.AddQuery(edamame.QueryCapability{Name: "async"})

    // Wait for async event processing
    if !capture.WaitForCount(1, 500*time.Millisecond) {
        t.Error("timed out waiting for event")
    }
}
```
