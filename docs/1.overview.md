---
title: Overview
description: Capability-driven query factory for Go applications
author: zoobzio
published: 2025-12-17
updated: 2025-12-17
tags:
  - Overview
  - Introduction
---

# Overview

Database operations in Go often mean choosing between raw SQL and heavy ORMs.

Edamame offers a third path: a capability-driven query factory that stays out of your way while providing introspection for AI integration.

```go
// Define your model
type User struct {
    ID    int    `db:"id" type:"integer" constraints:"primarykey"`
    Email string `db:"email" type:"text" constraints:"notnull,unique"`
    Name  string `db:"name" type:"text"`
    Age   *int   `db:"age" type:"integer"`
}

// Create a factory (CRUD capabilities auto-registered)
factory, err := edamame.New[User](db, "users", renderer)

// Use built-in capabilities
users, err := factory.ExecQuery(ctx, "query", nil)
user, err := factory.ExecSelect(ctx, "select", map[string]any{"id": 123})
inserted, err := factory.ExecInsert(ctx, &user)
deleted, err := factory.ExecDelete(ctx, "delete", map[string]any{"id": 123})

// Add custom capabilities
factory.AddQuery(edamame.QueryCapability{
    Name:        "adults",
    Description: "Find users over a minimum age",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "age", Operator: ">=", Param: "min_age"},
        },
        OrderBy: []edamame.OrderBySpec{
            {Field: "name", Direction: "asc"},
        },
    },
})

// Introspect for LLM integration
spec := factory.Spec()
json, _ := factory.SpecJSON()
```

Type-safe, injection-protected, introspectable.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                         Edamame                             │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                   Factory[T]                        │    │
│  │                                                     │    │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌────────┐  │    │
│  │  │ Queries  │ │ Selects  │ │ Updates  │ │Deletes │  │    │
│  │  └────┬─────┘ └────┬─────┘ └────┬─────┘ └───┬────┘  │    │
│  │       │            │            │           │       │    │
│  │       └────────────┴─────┬──────┴───────────┘       │    │
│  │                          │                          │    │
│  │                    ┌─────▼─────┐                    │    │
│  │                    │  Cereal   │                    │    │
│  │                    │ (Builder) │                    │    │
│  │                    └─────┬─────┘                    │    │
│  │                          │                          │    │
│  └──────────────────────────┼──────────────────────────┘    │
│                             │                               │
│                       ┌─────▼─────┐                         │
│                       │   sqlx    │                         │
│                       │    DB     │                         │
│                       └───────────┘                         │
└─────────────────────────────────────────────────────────────┘
```

Edamame provides named capabilities over cereal's query builder. Each capability maps a declarative spec to a parameterized SQL builder. The factory maintains capability registries with thread-safe access.

## Philosophy

Edamame bridges two worlds: the declarative simplicity of specs and the type safety of Go generics. Define what you want, get SQL that's validated at build time and parameterized at runtime.

```go
// In your user service
factory.AddQuery(edamame.QueryCapability{
    Name: "active-by-role",
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "active", Operator: "=", Param: "active"},
            {Field: "role", Operator: "=", Param: "role"},
        },
    },
})

// In your API handler
users, err := factory.ExecQuery(ctx, "active-by-role", map[string]any{
    "active": true,
    "role": "admin",
})

// In your LLM integration
spec := factory.SpecJSON()  // Expose capabilities to AI
```

Named capabilities, type-safe execution, introspectable specs.

## Capabilities

Edamame registers default CRUD capabilities automatically:

| Capability | Type      | Description                         |
| ---------- | --------- | ----------------------------------- |
| `query`    | Query     | Select all records                  |
| `select`   | Select    | Select single record by primary key |
| `delete`   | Delete    | Delete record by primary key        |
| `count`    | Aggregate | Count all records                   |

Add custom capabilities for your domain:

**[Queries](3.guides/2.capabilities.md#queries)** - Multi-record retrieval with filtering, sorting, pagination, and grouping.

**[Selects](3.guides/2.capabilities.md#selects)** - Single-record retrieval with optional locking.

**[Updates](3.guides/2.capabilities.md#updates)** - Targeted updates with SET clauses and WHERE conditions.

**[Deletes](3.guides/2.capabilities.md#deletes)** - Conditional deletion with WHERE clauses.

**[Aggregates](3.guides/2.capabilities.md#aggregates)** - COUNT, SUM, AVG, MIN, MAX with optional filtering.

## Priorities

### Type Safety

Fields, operators, and params are validated at query build time. No runtime SQL injection, no stringly-typed maps.

```go
// Spec-based: field names validated against model metadata
factory.AddQuery(edamame.QueryCapability{
    Spec: edamame.QuerySpec{
        Where: []edamame.ConditionSpec{
            {Field: "age", Operator: ">=", Param: "min_age"},
        },
    },
})

// Execution: params bound safely via sqlx
users, err := factory.ExecQuery(ctx, "adults", map[string]any{
    "min_age": 18,  // Parameterized, never interpolated
})
```

### Introspection

Every capability is introspectable. Get the full spec as Go structs or JSON:

```go
spec := factory.Spec()
json, _ := factory.SpecJSON()

// Use with LLMs, documentation generators, or API explorers
```

The spec includes capability names, descriptions, required parameters, and their types.

### Security

All SQL generation flows through cereal's validated builder:

- Field names validated against model metadata
- Operators validated against allowlist
- All values bound as parameters, never interpolated
- No raw SQL construction from user input

### Performance

- **Lazy initialization** - Builders created on demand
- **Thread-safe access** - Read locks for lookups, write locks only for registration
- **Minimal allocations** - Spec-to-builder conversion is lightweight
- **Batch operations** - Insert, update, delete batches in single transactions
